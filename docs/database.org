# -*- org-src-preserve-indentation: t; -*-
#+title: Almacenaje de datos
#+author: Eduardo Gomezcaña
#+property: header-args:python :tangle ../src/database.py
* Librerías
Se requiere poco para manejar la base de datos, con la librería de ~SQLite~ es
esencialmente suficiente. Se agregan algunas funciones de ~datetime~ para poder
convertir entre el formato de fechas nativo de /Python/ y el formato UTC con el
que se almacena en la base de datos.
#+begin_src python
import sqlite3
from datetime import date, datetime, time, timedelta
#+end_src

* Clase base
El módulo define una clase para manejar la base de datos usando la información
extraída por los /scrappers/ junto a funciones específicas para guardado y
extracción de tal información.
#+begin_src python :noweb yes
class FinancialDB:
    """Clase sencilla para el mantenimiento de los datos extraídos por los
    scrappers"""
    db_path = None

    <<constructor>>

    <<exe:execute>>

    <<exe:query>>

    <<exe:many>>

    <<aux:_symbols_ids>>

    <<aux:_utc2date>>

    <<aux:_date2utc>>

    <<consult:scrap_date>>

    <<consult:last_value>>

    <<consult:section_value>>

    <<consult:buys_timetable>>

    <<consult:accumulated_buys_timetable>>

    <<consult:value_history>>

    <<consult:section_symbols>>

    <<recent:full_value>>

    <<bulk:insert_product>>

    <<bulk:_op_processing>>

    <<bulk:insert_buys>>

    <<bulk:insert_prices>>
#+end_src

* Módulos de la clase
** Constructor
Lo único que se requiere para construir el objeto base de datos es la dirección
en la que está almacenado el archivo de SQLite.
#+name: constructor
#+begin_src python :tangle no
def __init__ (self, filepath):
    """Constructor que define el nombre del archivo de la base de datos"""

    # Define la localización de la base de datos cuando se requiera realizar una
    # conexión
    self.db_path = filepath
#+end_src
** Ejecución
La ejecución de ~queries~ suele ser un punto sensible y realmente aquí queremos
enmascarar en el objeto todo ese proceso, para realizarlo, vamos a encapsular la
llamada a través de algunas funciones auxiliares. La primera es la verdadera
envoltura (~wrap~) de la función, donde agregamos la posibilidad de atrapar
errores y de comandar el cursor de la base de datos de manera externa a través
de pasar una función.
#+name: exe:execute
#+begin_src python :tangle no
def _execute (self, calling_function):
    """Una evoltura para ~execute~ en SQLite. No se requiere toda la potencia de
    la librería al ser consultas muy dirigidas y la envoltura atrapa los errores
    y devuelve el resultado de la consulta para su manipulación posterior"""

    try:
        # Envuelve la posibilidad de fallo en la conexión a base de datos
        conn = sqlite3.connect(self.db_path)

        # Genera un cursor y usa la función para indicar la ejecución que se
        # desea a través de usar el cursor como parámetro
        cursor = conn.cursor()
        calling_function(cursor)

        # Guarda los posiles cambios realizados a la base de datos
        conn.commit()

        # Extrae la información que coleccionó el cursor de la ejecución
        return { 'fetched' : cursor.fetchall(),
                 'rowcount': cursor.rowcount,
                 'lastrowid': cursor.lastrowid }

    except sqlite3.Error as error:
        # Atrapa cualquier error en la ejecución de la base de datos y lo
        # devuelve para informar cuál fue el problema
        return error

    finally:
        # Una vez que retorna la función, se garantiza que la conexión se cierra
        # adecuadamente
        if conn:
            conn.close()
#+end_src

Una vez que tenemos esa envoltura, simplemente atraemos las funciones que nos
interesan y las encapsulamos a través de la función anterior permitiendo usar la
información que requieren. Esto permite hacer una llamada a la base de datos sin
tener que llamar a una conexión, el objeto termina manejando todo el proceso de
manera invisible.
#+name: exe:query
#+begin_src python :tangle no
def _execute_query (self, query_str, parameters=()):
    """Una evoltura para ~execute_many~ en SQLite para manejar los posibles
    problemas de manera externa"""

    # Indica cómo debe llamarse a execute usando el cursor cuando esté
    # disponible al conectarse a la base de datos
    return self._execute(lambda cur: cur.execute(query_str, parameters))
#+end_src

#+name: exe:many
#+begin_src python :tangle no
def _execute_many (self, query_str, parameters):
    """Una evoltura para ~execute_many~ en SQLite para manejar los posibles
    problemas de manera externa"""

    # Indica cómo debe llamarse a execute_many usando el cursor cuando esté
    # disponible al conectarse a la base de datos
    return self._execute(lambda cur: cur.executemany(query_str, parameters))
#+end_src

** Auxiliares
Frecuentemente se requiere atraer los valores de identificación de las filas
almacenadas en la tabla ~products~. La mayoría de las veces se requiere atraer
varios de esos elementos y se toma una posición maximalista (al no ser grande la
diversidad de elementos que se usan) cargando todos los productos en un
diccionario para poder guardar las tablas con la llave externa. Se espera que el
uso sea únicamente interno.
#+name: aux:_symbols_ids
#+begin_src python :tangle no
def _symbols_ids (self):
    """La función cumple una función auxiliar, hace una consulta de los IDs
    correspondientes con los productos registrados. El uso principal se da
    cuando deben insertarse datos nuevos en las tablas que compras y precios"""

    # Define una query para traer los IDs requeridos
    SQL_QUERY = "SELECT id, symbol, serie FROM products"

    # Ejecuta la query en la base de datos
    result = self._execute_query(SQL_QUERY)

    # Genera un diccionario para devolver el ID
    return { (symbol, serie) : db_id for db_id, symbol, serie in result["fetched"]}
#+end_src

#+name: aux:_utc2date
#+begin_src python :tangle no
@staticmethod
def _utc2date(utc_timestamp):
    return datetime.utcfromtimestamp(utc_timestamp).date()
#+end_src

#+name: aux:_date2utc
#+begin_src python :tangle no
@staticmethod
def _date2utc(given_date):
    return int(datetime.combine(given_date, time.min).timestamp())
#+end_src

** Consultas base
Una de las principales funciones que se requiere de la base de datos es
comunicarse con los /scrappers/. Una consulta frecuente y que los /scrappers/
requieren para saber que información atraer son las últimas fechas guardadas. La
función ~scrap_consult~ consulta la base de datos usando la lista de símbolos
(~symbol+serie~) y devuelve un diccionario usando éstas como sus claves, junto a
la fecha del último precio registrado en la base de datos. El resultado tiene el
objetivo de pasarse directamente a un scrapper para que consulte las fechas
que no están registradas usando la fecha actual.
#+name: consult:scrap_date
#+begin_src python :tangle no
def consult_scrap_date (self, symbols_list):
    """Dada una lista que describe parejas símbolo+serie, devuelve un
    diccionario usando esa misma pareja como clave y la información que se
    requiere para hacer una consulta con el scrapper lo cual consiste en la
    última fecha guardada y el origen del símbolo"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY = f"""SELECT products.symbol, products.serie, MAX(prices.date) FROM prices
    INNER JOIN products ON products.id = prices.symbol
    WHERE prices.symbol IN ({placeholders}) GROUP BY prices.symbol"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la lista de IDs para ejecutar la operación
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta
    result = self._execute_query(SQL_QUERY, data)

    # Crea el diccionario con la última fecha guardada
    return { (symbol, serie) : self._utc2date(utc_timestamp)
             for symbol, serie, utc_timestamp in result["fetched"]}
#+end_src

Otro de los usos que se requieren es comunicarse directamente con la colección
de funciones que nos permiten crear las gráficas del portafolio. Generalmente se
devuelven diccionario donde la información clave se reparte de manera que la
función sea capaz de dibujar sin problema alguno. Esto ayuda a que sea posible
conectar el resultado de estas funciones con la entrada de la función o
funciones que la usa.

Una de los usos más inmediatos es consultar el valor actual de algún producto.
Simplemente debe consultarse la cantidad acumulada del valor en compras, el
último precio registrado y crear el valor. Esto se hace paso a paso en una
consulta de ~SQL~ y simplemente se remata devolviendo ese valor. Debe tenerse en
cuenta que la función devuelve el valor usando la última fecha guardada y no la
fecha actual, para obtener el precio más reciente primero debe actualizarse la
base de datos. Justo por ese inconveniente, el resultado que se devuelve no sólo
es el valor del producto sino la fecha del precio de referencia que usa para
calcular ese valor.
#+name: consult:last_value
#+begin_src python :tangle no
def consult_last_value (self, symbols_list):
    """Dada una lista que describe parejas símbolo+serie, devuelve un
    diccionario usando esa misma pareja como clave y devuelve el último precio
    registrado y la fecha de consulta"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY1 = f"""SELECT symbol, SUM(qty) AS total_qty
    FROM buys WHERE symbol IN ({placeholders}) GROUP BY symbol"""

    SQL_QUERY2 = f"""SELECT symbol, price, MAX(date) AS last_date
    FROM prices WHERE symbol IN ({placeholders}) GROUP BY symbol"""

    FULL_QUERY = f"""WITH total_buys AS ({SQL_QUERY1}), last_prices AS ({SQL_QUERY2})
    SELECT products.symbol, products.serie, total_buys.total_qty*last_prices.price, last_prices.last_date
    FROM total_buys
    JOIN last_prices ON total_buys.symbol=last_prices.symbol
    JOIN products ON products.id = total_buys.symbol"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la lista de IDs para ejecutar la operación
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(FULL_QUERY, data+data)

    # Crea el diccionario con la última fecha guardada y el valor económico
    return { (symbol, serie) : {"date" : self._utc2date(utc_timestamp), "value" : value}
             for symbol, serie, value, utc_timestamp in result["fetched"]}
#+end_src

También es elemental comparar las diferentes secciones a las que los productos
pertenecen y conocer el valor de esos grupos. Esto implica un proceso similar al
anterior, donde se debe ir a la tabla de compras para saber la cantidad de cada
activo que se tiene y luego a la tabla de precios para consultar el precio más
reciente para generar el valor. Con esta información se consulta la tabla de
productos y se agrupa por sección sumando los valores de cada activo que
contengan. Hay una pequeña clausula para evitar que se devuelvan algunas
secciones, aunque tal exclusión no mejor la ejecución (eso probablemente se
tenga mejorar si es que algún día el volumen de datos crece).
#+name: consult:section_value
#+begin_src python :tangle no
def consult_section_value(self, exclude = []):
    """Consulta en la base de datos el valor acumulado de todos los activos en
    las diferentes secciones registradas en la table de productos a menos que
    sea excluida en la lista"""

    # Define la instrucción requerida en la consulta
    SQL_QUERY1 = f"""SELECT symbol, SUM(qty) AS total_qty
    FROM buys GROUP BY symbol"""

    SQL_QUERY2 = f"""SELECT symbol, price, MAX(date) AS last_date
    FROM prices GROUP BY symbol"""

    SQL_QUERY3 = f"""SELECT total_buys.symbol AS symbol, total_buys.total_qty*last_prices.price AS value
    FROM total_buys JOIN last_prices ON total_buys.symbol=last_prices.symbol"""

    FULL_QUERY = f"""WITH total_buys AS ({SQL_QUERY1}), last_prices AS ({SQL_QUERY2}), symbol_value AS ({SQL_QUERY3})
    SELECT products.secc, SUM(value) FROM symbol_value
    JOIN products ON products.id = symbol_value.symbol
    GROUP BY products.secc"""

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(FULL_QUERY)

    # Crea el diccionario con la última fecha guardada y el valor económico
    return { section : round(last_value,2)
             for section, last_value in result["fetched"] if section not in exclude}
#+end_src

En muchas ocasiones, se necesita saber el orden en las compras para reportar que
el valor de un producto ha subido no por las fluctuaciones de precio sino porque
se ha adquirido más de éste. En ese caso, se extraen todas las compras del
producto y se devuelve un diccionario con las compras realizadas en ese periodo.
El único cambio es que la fecha inicial que se pide, acumula todo el valor de
compra que se ha adquirido hasta esa fecha, el resto son reportes de compras
individuales.
#+name: consult:buys_timetable
#+begin_src python :tangle no
def consult_buys_timetable(self, symbols_list, init, end):
    """Consulta la lista de compras y devuelve un diccionario con las claves de
    los símbolos (symbol+serie) y cada clave tiene asignado otro diccionario con
    las fechas como claves y el gasto del producto en esa fecha"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY = f"""SELECT products.symbol, products.serie, buys.date, buys.price
    FROM buys JOIN products ON products.id = buys.symbol
    WHERE buys.symbol IN ({placeholders})
    ORDER BY buys.date"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la información para generar la consulta
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(SQL_QUERY, data)

    # Inicializa los calendarios de compras
    symbol_full_timetable = {key_pair: {} for key_pair in symbols_list}

    # Agrega por diccionario y por fecha
    for symbol, serie, utc_date, op_cost in result["fetched"]:
        key = (symbol,serie)
        current_date = self._utc2date(utc_date)
        symbol_full_timetable[key][current_date] = round(op_cost,2)

    # Inicializa el calendario limitado de compras
    symbol_corrected_timetable = {key_pair: {} for key_pair in symbols_list}

    # Ajusta las fechas previas al inicio
    for symbol_pair, buy_dates in symbol_full_timetable.items():
        pre_dates_value = sum([op_cost  for date, op_cost in buy_dates.items() if date <= init])
        valid_dates_timetable = { date: value for date, value in buy_dates.items() if date > init and date <= end}
        corrected_dates_timetable = { init: pre_dates_value } | (valid_dates_timetable)
        symbol_corrected_timetable[symbol_pair] = corrected_dates_timetable

    # Devuelve las acciones de compras
    return symbol_corrected_timetable
#+end_src

En otras ocasiones se requiere consultar cuánto se ha invertido en cierto
producto hasta una fecha dada para conocer cómo se ha comportado la inversión y
la tasa de retorno. Esta función extrae esa información considerando que se
extrae en valor de compra sin ninguna clase de ajuste, sólo se hace en bruto.
#+name: consult:accumulated_buys_timetable
#+begin_src python :tangle no
def consult_accumulated_buys_timetable(self, symbols_list, init, end):
    """Consulta la lista de compras y devuelve un diccionario con las claves de
    los símbolos (symbol+serie) y cada clave tiene asignado otro diccionario con
    las fechas como claves y el gasto involucrado hasta esa fecha"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY = f"""SELECT products.symbol, products.serie, buys.date, SUM(buys.price) OVER (
    PARTITION BY buys.symbol
    ORDER BY buys.date
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
    FROM buys JOIN products ON products.id = buys.symbol
    WHERE buys.symbol IN ({placeholders})
    ORDER BY buys.date"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la información para generar la consulta
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(SQL_QUERY, data)

    # Inicializa los calendarios de compras
    symbol_full_timetable = {key_pair: {} for key_pair in symbols_list}

    # Agrega por diccionario y por fecha
    for symbol, serie, utc_date, accumulated_cost in result["fetched"]:
        key = (symbol,serie)
        current_date = self._utc2date(utc_date)
        symbol_full_timetable[key][current_date] = round(accumulated_cost,2)

    # Inicializa el calendario limitado de compras
    symbol_corrected_timetable = {key_pair: {} for key_pair in symbols_list}

    # Ajusta las fechas previas al inicio
    for symbol_pair, buy_dates in symbol_full_timetable.items():
        pre_dates = [date for date in buy_dates.keys() if date <= init]
        corrected_first_value = 0.0 if len(pre_dates) == 0 else buy_dates[max(pre_dates)]
        valid_dates_timetable = { date: value for date, value in buy_dates.items() if date > init and date <= end}
        corrected_dates_timetable = { init: corrected_first_value } | (valid_dates_timetable)
        symbol_corrected_timetable[symbol_pair] = corrected_dates_timetable

    # Devuelve las acciones de compra
    return symbol_corrected_timetable
#+end_src

Una de las consultas más recurrentes, requiere conocer el valor de los activos a
la fecha actual con los precios actuales. Probablemente es la consulta estándar
más compleja de todas.
#+name: consult:value_history
#+begin_src python :tangle no
def consult_value_history(self, symbols_list, init, end):
    """Consulta los precios registrados de los activos en la lista de símbolos y
    también la cantidad acumulada del producto, y calula el valor del producto
    en esas fechas. Luego devuelve un diccionario con los símbolos como claves y
    como datos otro diccionario indicando las fechas y valor del activo en esa
    fecha"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY1 = f"""SELECT products.symbol, products.serie, buys.date, SUM(buys.qty) OVER (
    PARTITION BY buys.symbol
    ORDER BY buys.date
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
    FROM buys
    JOIN products ON products.id = buys.symbol
    WHERE buys.symbol IN ({placeholders})
    ORDER BY buys.date"""

    SQL_QUERY2 = f"""SELECT products.symbol, products.serie, prices.date, prices.price FROM prices
    JOIN products ON products.id = prices.symbol
    WHERE prices.symbol IN ({placeholders})
    AND prices.date >= ? AND prices.date <= ?
    ORDER BY prices.date"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la información para generar la consulta
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Genera las fechas de consulta bajo las fechas dadas
    utc_init, utc_end = self._date2utc(init), self._date2utc(end)

    # Ejecuta la consulta y los placeholders de la primera query
    result1 = self._execute_query(SQL_QUERY1, data)

    # Inicializa diccionario para capturar información
    symbol_timetable = { key_pair : {} for key_pair in symbols_list}

    # Recupera la información de la consulta
    for symbol, serie, utc_date, acc_qty in result1["fetched"]:
        symbol_key = (symbol, serie)
        symbol_timetable[symbol_key][self._utc2date(utc_date)] = acc_qty

    # Ejecuta la consulta y los placeholders de la primera query
    result2 = self._execute_query(SQL_QUERY2, data + [utc_init, utc_end])

    # Inicializa diccionario para capturar información
    symbol_values = { key_pair : {} for key_pair in symbols_list}

    # Recupera la información de la consulta
    for symbol, serie, utc_date, price in result2["fetched"]:
        symbol_key = (symbol, serie)
        price_date = self._utc2date(utc_date)
        viable_buy_dates = [ buy_date for buy_date in symbol_timetable[symbol_key].keys() if buy_date < price_date]
        if len(viable_buy_dates) == 0:
            qty = 0.0
        else:
            buy_date = max(viable_buy_dates)
            qty = symbol_timetable[symbol_key][buy_date]
        symbol_values[symbol_key][price_date] =  price * qty

    # Devuelve la información recolectada
    return symbol_values
#+end_src

#+name: consult:section_symbols
#+begin_src python :tangle no
def consult_section_symbols(self, section_str):
    """Dado el nombre de una sección, devuelve las claves de los productos que
    pertenecen a ésta"""

    # Define la instrucción requerida en la consulta
    SQL_QUERY = """SELECT products.symbol, products.serie FROM buys
    JOIN products ON products.id = buys.symbol
    WHERE products.secc = ?
    GROUP BY buys.symbol HAVING SUM(buys.qty) > 0"""

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(SQL_QUERY, [section_str])

    # Devuelve directamente la lista con la claves
    return result["fetched"]
#+end_src

** Consultas especiales
Se crea una función que aglutina compras e historia de precios en su respuesta.
El objetivo es formar un objeto que pueda transmitirse directamente a una de las
funciones de graficación para visualizar no sólo los cambios de valor sino los
saltos en valor provocados por las compras de producto.
#+name: recent:full_value
#+begin_src python :tangle no
def recent_full_value_history(self, symbols_list):
    """Usando la lista de símbolos, se genera la historia de valores y compras
    de cada producto. La idea es coleccionar toda la información necesaría para
    gráficar la historia del activo de manera que se puedan apreciar todos los
    cambios que suceden"""

    # Se usa la fecha actual para hacer la consulta
    today = datetime.today().date()

    # Y se atraen las últimas 30 semanas desde la fecha actual
    today_minus_30 = today - timedelta(weeks=30)

    # Se realizan las dos consultas con la información
    values = self.consult_value_history(symbols_list, today_minus_30, today)
    buys = self.consult_buys_timetable(symbols_list, today_minus_30, today)

    # Se devuelven los elementos como una pareja
    return values, buys

#+end_src

** Actualizaciones en masa
Para administrar los productos financieros que se requieren, se usa una tabla
administrada usando ~org~. Esa tabla contiene todos los activos de interés con
la respectiva información. Esencialmente, se busca hacer un /dump/ de la tabla
en la base de datos. La tabla en cuestión tiene la siguiente forma:

| Sección | Emisora | Serie   | Origen | Tipo | Compañía | Notas |
|---------+---------+---------+--------+------+----------+-------|
| STR     | STR     | STR/NUM | STR    | STR  | STR      | TEXT  |
|         |         |         |        |      |          |       |
|---------+---------+---------+--------+------+----------+-------|
| STR     | STR     | STR/NUM | STR    | STR  | STR      | TEXT  |
|         |         |         |        |      |          |       |

Para poder guardar la información de la tabla, debe observarse que la primera
columna contiene información sólo en algunas entradas, asumiendo que se acarrea
de la entrada anterior no nula. La idea es procesar cada fila y generar una
versión que contenga la información que se desea guardar y dejar que ~SQLite~
decida si hay o no productos nuevos al almacenar.

#+name: bulk:insert_product
#+begin_src python :tangle no
def bulk_insert_product(self, data_table, start_row=1):
    """Para una tabla con la información relevante, inserta cada fila en masa
    dentro de la base de datos. Esto se considegu
    e extrayendo la información de
    cada fila y organizándola en una tupla"""

    SQL_INSERT = "INSERT OR IGNORE INTO products(symbol,serie,src,secc) VALUES (?,?,?,?)"

    data = []
    current_section = ""
    for section, symbol, serie, source,_,_,_ in data_table[start_row:]:
        if section != '':
            current_section = section
        insert_row = (symbol, serie, source, current_section)
        data.append(insert_row)

    return self._execute_many(SQL_INSERT, data)
#+end_src

Para registras las compras/ventas, se usan tablas con la información relevante y
tienen la siguiente forma. Muchos de los espacios nacen a consideración de
algunos cálculo que se realizar en la tabla usando la capacidades de ~org~ para
su manipulación.

|   | Cartera | Producto | Serie   | Fecha    | Status    | Cantidad | Valor unitario | Costo agregado | Comisión | IVA | Costo total | Anotaciones |
|   |         |          |         |          |           |          |                |                |          |     |             |             |
|---+---------+----------+---------+----------+-----------+----------+----------------+----------------+----------+-----+-------------+-------------|
|   | STR     | STR      | STR/NUM | %Y-%m-%d | DONE/TODO | NUM      | NUM            | NUM            | NUM      | NUM | NUM         | TEXT        |

Hay que tener en cuenta que esas tablas tienen una finalidad de ayuda visual y
contienen información que puede ser reconstruida después o es innecesaria por lo
que decide no guardarse. Además de esos valores descartados, debe asegurarse que
los valores tengan la estructura correcta y en particular, deben distinguirse
las tablas que registran las compras (valor positivo) de las ventas (valor
negativo). Durante el registro de las tablas, no se hace explícito ese signo lo
que hace imperativo que se registre esto durante el procesamiento en la
siguiente función.
#+name: bulk:_op_processing
#+begin_src python :tangle no
@staticmethod
def _bulk_op_processing(data_table, start_row=2, sign=1):
     """Al recibir la tabla, debe definirse si el valor de la transacción es
     positivo o negativo y si admitir sólo operaciones completadas. También se
     hacen ajustes menores a los tipos de datos para garantizar que sean los
     mismos que se tienen en la base de datos. La función se aisla porque el
     proceso se realiza sobre al menos dos tablas de la misma forma antes de
     continuar"""

     # Regenera las filas de tabla, transformando la información que se ingresa
     return [(str(symbol), str(serie), int(datetime.strptime(date, "%Y-%m-%d").timestamp()), sign*qty, sign*price)
             for _, _, symbol, serie, date, status, qty, _, _, _, _, price,_ in data_table[start_row:]
             if status == 'DONE']
#+end_src

Una vez procesada la información de la tabla, tenemos una colección de todos los
tickets emitidos en una sola lista. La tabla de compras busca registrar las
operaciones en un día, y aunque la tabla registre varias ventas o compras en un
día, deben consolidarse acumulándose en una sola y esto es lo que se guarda en
la tabla. Tiene un efecto indeseable que combinaría compras y ventas de un
producto en un sólo día pero eso se considera irrelevante al no ser una práctica
deseable. Una vez acumuladas, se generan las filas que van a almacenarse y se
guardan en la tabla correspondiente.
#+name: bulk:insert_buys
#+begin_src python :tangle no
def bulk_insert_buys(self, buys_table, sells_table, start_row=2):
    """Para una tabla con la información relevante para una compra (si sign=1) o
    una venta (si sign=-1), inserta esa información dentro de la base de datos
    con una potencial modificación: Para insertar una fila con un elemento único
    se requiere símbolo y fecha de compra/venta. Esto quiere decir las filas
    deben acumularse antes de insertarse."""

    # Define el query requerida para la operación
    SQL_INSERT = "INSERT OR IGNORE INTO buys(symbol,qty,price,date) VALUES (?,?,?,?)"

    # Extrae los IDs de la base de datos
    ids_dictionary = self._symbols_ids()

    # Une los tickets de compra y venta en una lista
    tickets = self._bulk_op_processing(buys_table, start_row=start_row, sign=1) + self._bulk_op_processing(sells_table, start_row=start_row, sign=-1)

    # Acumula los valores de compra y venta diarios por symbol+serie+date usando
    # el ID de symbol+serie en la base de datos
    day_tickets = {}
    for symbol, serie, utc_timestamp, qty, price in tickets:
        ticket_key = (ids_dictionary[(symbol,serie)], utc_timestamp)
        ticket_qty_price = day_tickets.get(ticket_key, (0.0, 0.0))
        day_tickets[ticket_key] = tuple(a + b for a, b in zip(ticket_qty_price, (qty,price)))

    # Organiza la información acumulada para insertar la información
    data = [ (symbol_id, qty, price, utc_timestamp) for (symbol_id, utc_timestamp), (qty, price) in day_tickets.items() ]

    # Devuelve el resultado de ejecutar la query
    return self._execute_many(SQL_INSERT, data)
#+end_src

Finalmente, el objetivo principal de la base de datos es guardar los precios que
se han descargado para no tener que consultarlos de vuelta. Para eso, se atrae
el diccionario con el que se interactúa en los ~scrappers~ y convierte éste en
las filas que deben insertarse en la tabla de precios.
#+name: bulk:insert_prices
#+begin_src python :tangle no
def bulk_insert_prices(self, scraps_dictionary):
    # Define el query requerida para la operación
    SQL_INSERT = "INSERT OR IGNORE INTO prices(symbol,date,price) VALUES (?,?,?)"

    # Extrae los IDs de la base de datos
    ids_dictionary = self._symbols_ids()

    # Organiza las inserciones que debe realizarse como tuplas
    data = [ (ids_dictionary[symbol_key], self._date2utc(date) , price)
             for symbol_key, prices_dictionary in scraps_dictionary.items()
             for date, price in prices_dictionary.items()]

    return self._execute_many(SQL_INSERT, data)
#+end_src

* Base de datos
La estructura de la base de datos es sencilla y la podemos describir con un
comando de ~SQL~. Ésta contiene tres tablas para almacenar los productos
financieros que se utilizan, los precios de los productos que se usan, y las
compras/ventas de cada uno. Con todo esto, se pretende dar un seguimiento del
portafolio. En el caso de un producto, se usa su símbolo y serie para que este
sea único junto con el identificador como clave primaria. En el caso de los
precios, el rol de la unicidad lo juega el identificador del símbolo (como clave
externa) y la fecha, sólo se quiere un precio por día. Finalmente, la unicidad
en una compra se consigue con el símbolo (de nuevo como clave externa), junto al
precio y la fecha. Esto último es un poco forzado y de momento funciona pero
como las fechas se guardan como un entero representando la una hora estándar del
día en UTC, se podría cambiar para que fuera única en el sentido de la hora con
segundos incluidos si fuera necesario.
#+name: db-structure
#+begin_src sqlite :results silent
CREATE TABLE IF NOT EXISTS products (
       id INTEGER UNIQUE PRIMARY KEY,
       symbol TEXT NOT NULL,
       serie TEXT,
       src TEXT,
       secc TEXT,
       UNIQUE(symbol, serie));
CREATE TABLE IF NOT EXISTS prices (
       id INTEGER UNIQUE PRIMARY KEY,
       symbol INTEGER NOT NULL,
       date INTEGER NOT NULL,
       price REAL NOT NULL,
       UNIQUE(symbol, date),
       FOREIGN KEY(symbol) REFERENCES products(id));
CREATE TABLE IF NOT EXISTS buys (
       id INTEGER UNIQUE PRIMARY KEY,
       symbol INTEGER NOT NULL,
       qty REAL NOT NULL,
       price REAL NOT NULL,
       date INTEGER NOT NULL,
       UNIQUE(symbol, price, date),
       FOREIGN KEY(symbol) REFERENCES products(id));
#+end_src
