# -*- org-src-preserve-indentation: t; -*-
#+title: Almacenaje de datos
#+author: Eduardo Gomezcaña
#+property: header-args:python :tangle ../src/database.py
* Librerías
No se requieren muchas librerías para realizar el /scrap/, basta uasr la
/requests/ para manejar las transacciones, /json/ para obtener objetos de las
cadenas con las que responde la /API/ y una serie de manejo de fechas para
organizar correctamente la información que se consulta.
#+begin_src python
import sqlite3
from datetime import date, datetime, time
#+end_src

* Clase base
El módulo define una clase para manejar la base de datos usando la información
extraída por los /scrappers/ junto a funciones específicas para guardado y
extracción de tal información.
#+begin_src python :noweb yes
class FinancialDB:
    """Clase sencilla para el mantenimiento de los datos extraídos por los
    scrappers"""
    db_path = None

    <<constructor>>

    <<exe:execute>>

    <<exe:query>>

    <<exe:many>>

    <<aux:_symbols_ids>>

    <<aux:_utc2date>>

    <<aux:_date2utc>>

    <<consult:scrap_date>>

    <<consult:last_value>>

    <<consult:section_value>>

    <<consult:buys_timetable>>

    <<consult:section_symbols>>

    <<bulk:insert_product>>

    <<bulk:_op_processing>>

    <<bulk:insert_buys>>

    <<bulk:insert_prices>>
#+end_src

* Módulos de la clase
** Constructor
Lo único que se requiere para construir el objeto base de datos es la dirección
en la que está almacenado el archivo de SQLite.
#+name: constructor
#+begin_src python :tangle no
def __init__ (self, filepath):
    """Constructor que define el nombre del archivo de la base de datos"""

    # Define la localización de la base de datos cuando se requiera realizar una
    # conexión
    self.db_path = filepath
#+end_src

** Ejecución
La ejecución de ~queries~ suele ser un punto sensible y realmente aquí queremos
enmascarar en el objeto todo ese proceso, para realizarlo, vamos a encapsular la
llamada a través de algunas funciones auxiliares. La primera es la verdadera
envoltura (~wrap~) de la función, donde agregamos la posibilidad de atrapar
errores y de comandar el cursor de la base de datos de manera externa a través
de pasar una función.
#+name: exe:execute
#+begin_src python :tangle no
def _execute (self, calling_function):
    """Una evoltura para ~execute~ en SQLite. No se requiere toda la potencia de
    la librería al ser consultas muy dirigidas y la envoltura atrapa los errores
    y devuelve el resultado de la consulta para su manipulación posterior"""

    try:
        # Envuelve la posibilidad de fallo en la conexión a base de datos
        conn = sqlite3.connect(self.db_path)

        # Genera un cursor y usa la función para indicar la ejecución que se
        # desea a través de usar el cursor como parámetro
        cursor = conn.cursor()
        calling_function(cursor)

        # Guarda los posiles cambios realizados a la base de datos
        conn.commit()

        # Extrae la información que coleccionó el cursor de la ejecución
        return { 'fetched' : cursor.fetchall(),
                 'rowcount': cursor.rowcount,
                 'lastrowid': cursor.lastrowid }

    except sqlite3.Error as error:
        # Atrapa cualquier error en la ejecución de la base de datos y lo
        # devuelve para informar cuál fue el problema
        return error

    finally:
        # Una vez que retorna la función, se garantiza que la conexión se cierra
        # adecuadamente
        if conn:
            conn.close()
#+end_src

Una vez que tenemos esa envoltura, simplemente atraemos las funciones que nos
interesan y las encapsulamos a través de la función anterior permitiendo usar la
información que requieren. Esto permite hacer una llamada a la base de datos sin
tener que llamar a una conexión, el objeto termina manejando todo el proceso de
manera invisible.
#+name: exe:query
#+begin_src python :tangle no
def _execute_query (self, query_str, parameters=()):
    """Una evoltura para ~execute_many~ en SQLite para manejar los posibles
    problemas de manera externa"""

    # Indica cómo debe llamarse a execute usando el cursor cuando esté
    # disponible al conectarse a la base de datos
    return self._execute(lambda cur: cur.execute(query_str, parameters))
#+end_src

#+name: exe:many
#+begin_src python :tangle no
def _execute_many (self, query_str, parameters):
    """Una evoltura para ~execute_many~ en SQLite para manejar los posibles
    problemas de manera externa"""

    # Indica cómo debe llamarse a execute_many usando el cursor cuando esté
    # disponible al conectarse a la base de datos
    return self._execute(lambda cur: cur.executemany(query_str, parameters))
#+end_src

** Auxiliares
Frecuentemente se requiere atraer los valores de identificación de las filas
almacenadas en la tabla ~products~. La mayoría de las veces se requiere atraer
varios de esos elementos y se toma una posición maximalista (al no ser grande la
diversidad de elementos que se usan) cargando todos los productos en un
diccionario para poder guardar las tablas con la llave externa. Se espera que el
uso sea únicamente interno.
#+name: aux:_symbols_ids
#+begin_src python :tangle no
def _symbols_ids (self):
    """La función cumple una función auxiliar, hace una consulta de los IDs
    correspondientes con los productos registrados. El uso principal se da
    cuando deben insertarse datos nuevos en las tablas que compras y precios"""

    # Define una query para traer los IDs requeridos
    SQL_QUERY = "SELECT id, symbol, serie FROM products"

    # Ejecuta la query en la base de datos
    result = self._execute_query(SQL_QUERY)

    # Genera un diccionario para devolver el ID
    return { (symbol, serie) : db_id for db_id, symbol, serie in result["fetched"]}
#+end_src

#+name: aux:_utc2date
#+begin_src python :tangle no
@staticmethod
def _utc2date(utc_timestamp):
    return datetime.utcfromtimestamp(utc_timestamp).date()
#+end_src

#+name: aux:_date2utc
#+begin_src python :tangle no
@staticmethod
def _date2utc(given_date):
    return int(datetime.combine(given_date, time.min).timestamp())
#+end_src


** Consultas base
Una de las principales funciones que se requiere de la base de datos es
comunicarse con los /scrappers/. Una consulta frecuente y que los /scrappers/
requieren para saber que información atraer son las últimas fechas guardadas. La
función ~scrap_consult~ consulta la base de datos usando la lista de símbolos
(~symbol+serie~) y devuelve un diccionario usando éstas como sus claves, junto a
la fecha del último precio registrado en la base de datos. El resultado tiene el
objetivo de pasarse directamente a un scrapper para que consulte las fechas
que no están registradas usando la fecha actual.
#+name: consult:scrap_date
#+begin_src python :tangle no
def consult_scrap_date (self, symbols_list):
    """Dada una lista que describe parejas símbolo+serie, devuelve un
    diccionario usando esa misma pareja como clave y la información que se
    requiere para hacer una consulta con el scrapper lo cual consiste en la
    última fecha guardada y el origen del símbolo"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY = f"""SELECT products.symbol, products.serie, MAX(prices.date) FROM prices
    INNER JOIN products ON products.id = prices.symbol
    WHERE prices.symbol IN ({placeholders}) GROUP BY prices.symbol"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la lista de IDs para ejecutar la operación
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta
    result = self._execute_query(SQL_QUERY, data)

    # Crea el diccionario con la última fecha guardada
    return { (symbol, serie) : self._utc2date(utc_timestamp)
             for symbol, serie, utc_timestamp in result["fetched"]}
#+end_src

Otro de los usos que se requieren es comunicarse directamente con la colección
de funciones que nos permiten crear las gráficas del portafolio. Generalmente se
devuelven diccionario donde la información clave se reparte de manera que la
función sea capaz de dibujar sin problema alguno. Esto ayuda a que sea posible
conectar el resultado de estas funciones con la entrada de la función o
funciones que la usa.

Una de los usos más inmediatos es consultar el valor actual de algún producto.
Simplemente debe consultarse la cantidad acumulada del valor en compras, el
último precio registrado y crear el valor. Esto se hace paso a paso en una
consulta de ~SQL~ y simplemente se remata devolviendo ese valor. Debe tenerse en
cuenta que la función devuelve el valor usando la última fecha guardada y no la
fecha actual, para obtener el precio más reciente primero debe actualizarse la
base de datos. Justo por ese inconveniente, el resultado que se devuelve no sólo
es el valor del producto sino la fecha del precio de referencia que usa para
calcular ese valor.
#+name: consult:last_value
#+begin_src python :tangle no
def consult_last_value (self, symbols_list):
    """Dada una lista que describe parejas símbolo+serie, devuelve un
    diccionario usando esa misma pareja como clave y devuelve el último precio
    registrado y la fecha de consulta"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY1 = f"""SELECT symbol, SUM(qty) AS total_qty
    FROM buys WHERE symbol IN ({placeholders}) GROUP BY symbol"""

    SQL_QUERY2 = f"""SELECT symbol, price, MAX(date) AS last_date
    FROM prices WHERE symbol IN ({placeholders}) GROUP BY symbol"""

    FULL_QUERY = f"""WITH total_buys AS ({SQL_QUERY1}), last_prices AS ({SQL_QUERY2})
    SELECT products.symbol, products.serie, total_buys.total_qty*last_prices.price, last_prices.last_date
    FROM total_buys
    JOIN last_prices ON total_buys.symbol=last_prices.symbol
    JOIN products ON products.id = total_buys.symbol"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la lista de IDs para ejecutar la operación
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(FULL_QUERY, data+data)

    # Crea el diccionario con la última fecha guardada y el valor económico
    return { (symbol, serie) : {"date" : self._utc2date(utc_timestamp), "value" : value}
             for symbol, serie, value, utc_timestamp in result["fetched"]}
#+end_src

También es elemental comparar las diferentes secciones a las que los productos
pertenecen y conocer el valor de esos grupos. Esto implica un proceso similar al
anterior, donde se debe ir a la tabla de compras para saber la cantidad de cada
activo que se tiene y luego a la tabla de precios para consultar el precio más
reciente para generar el valor. Con esta información se consulta la tabla de
productos y se agrupa por sección sumando los valores de cada activo que
contengan. Hay una pequeña clausula para evitar que se devuelvan algunas
secciones, aunque tal exclusión no mejor la ejecución (eso probablemente se
tenga mejorar si es que algún día el volumen de datos crece).
#+name: consult:section_value
#+begin_src python :tangle no
def consult_section_value(self, exclude = []):
    """Consulta en la base de datos el valor acumulado de todos los activos en
    las diferentes secciones registradas en la table de productos a menos que
    sea excluida en la lista"""

    # Define la instrucción requerida en la consulta
    SQL_QUERY1 = f"""SELECT symbol, SUM(qty) AS total_qty
    FROM buys GROUP BY symbol"""

    SQL_QUERY2 = f"""SELECT symbol, price, MAX(date) AS last_date
    FROM prices GROUP BY symbol"""

    SQL_QUERY3 = f"""SELECT total_buys.symbol AS symbol, total_buys.total_qty*last_prices.price AS value
    FROM total_buys JOIN last_prices ON total_buys.symbol=last_prices.symbol"""

    FULL_QUERY = f"""WITH total_buys AS ({SQL_QUERY1}), last_prices AS ({SQL_QUERY2}), symbol_value AS ({SQL_QUERY3})
    SELECT products.secc, SUM(value) FROM symbol_value
    JOIN products ON products.id = symbol_value.symbol
    GROUP BY products.secc"""

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(FULL_QUERY)

    # Crea el diccionario con la última fecha guardada y el valor económico
    return { section : round(last_value,2)
             for section, last_value in result["fetched"] if section not in exclude}
#+end_src

#+name: consult:buys_timetable
#+begin_src python :tangle no
def consult_buys_timetable(self, symbols_list, init, end):
    """Consulta la lista de compras y devuelve un diccionario con las claves de
    los símbolos (symbol+serie) y loa valores son arreglos de parejas con la
    fecha de compra y el valor invertido hasta esa fecha"""

    # Define la instrucción requerida en la consulta
    placeholders = ','.join(['?']*len(symbols_list))
    SQL_QUERY = f"""SELECT products.symbol, products.serie, buys.date, buys.price FROM buys
    JOIN products ON products.id = buys.symbol
    WHERE buys.symbol IN ({placeholders}) ORDER BY buys.date"""

    # Atrae el diccionario de IDs para símbolo+serie
    ids_dictionary = self._symbols_ids()

    # Genera la información para generar la consulta
    data = [ids_dictionary[key_pair] for key_pair in symbols_list]

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(SQL_QUERY, data)

    # Inicializa los costos acumulados
    accumulated_cost = { key_pair: 0.0 for key_pair in symbols_list}

    # Inicializa los calendarios de compras
    symbol_timetable = {key_pair: [] for key_pair in symbols_list}

    # Agrega por diccionario y por fecha
    for symbol, serie, utc_date, cost in result["fetched"]:
        key = (symbol,serie)
        accumulated_cost[key] += cost
        current_date = self._utc2date(utc_date)
        if init <= current_date and current_date <= end:
            symbol_timetable[key] += [(current_date, round(accumulated_cost[key],2))]

    # Devuelve las acciones de compra
    return symbol_timetable
#+end_src

#+name: consult:section_symbols
#+begin_src python :tangle no
def consult_section_symbols(self, section_str):
    """Dado el nombre de una sección, devuelve las claves de los productos que
    pertenecen a ésta"""

    # Define la instrucción requerida en la consulta
    SQL_QUERY = """SELECT products.symbol, products.serie FROM buys
    JOIN products ON products.id = buys.symbol
    WHERE products.secc = ?
    GROUP BY buys.symbol HAVING SUM(buys.qty) > 0"""

    # Ejecuta la consulta y los placeholders deben acumularse
    result = self._execute_query(SQL_QUERY, [section_str])

    # Devuelve directamente la lista con la claves
    return result["fetched"]
#+end_src

** Actualizaciones en masa
Para administrar los productos financieros que se requieren, se usa una tabla
administrada usando ~org~. Esa tabla contiene todos los activos de interés con
la respectiva información. Esencialmente, se busca hacer un /dump/ de la tabla
en la base de datos. La tabla en cuestión tiene la siguiente forma:

| Sección | Emisora | Serie   | Origen | Tipo | Compañía | Notas |
|---------+---------+---------+--------+------+----------+-------|
| STR     | STR     | STR/NUM | STR    | STR  | STR      | TEXT  |
|         |         |         |        |      |          |       |
|---------+---------+---------+--------+------+----------+-------|
| STR     | STR     | STR/NUM | STR    | STR  | STR      | TEXT  |
|         |         |         |        |      |          |       |

Para poder guardar la información de la tabla, debe observarse que la primera
columna contiene información sólo en algunas entradas, asumiendo que se acarrea
de la entrada anterior no nula. La idea es procesar cada fila y generar una
versión que contenga la información que se desea guardar y dejar que ~SQLite~
decida si hay o no productos nuevos al almacenar.

#+name: bulk:insert_product
#+begin_src python :tangle no
def bulk_insert_product(self, data_table, start_row=1):
    """Para una tabla con la información relevante, inserta cada fila en masa
    dentro de la base de datos. Esto se considegu
    e extrayendo la información de
    cada fila y organizándola en una tupla"""

    SQL_INSERT = "INSERT OR IGNORE INTO products(symbol,serie,src,secc) VALUES (?,?,?,?)"

    data = []
    current_section = ""
    for section, symbol, serie, source,_,_,_ in data_table[start_row:]:
        if section != '':
            current_section = section
        insert_row = (symbol, serie, source, current_section)
        data.append(insert_row)

    return self._execute_many(SQL_INSERT, data)
#+end_src

Para registras las compras/ventas, se usan tablas con la información relevante y
tienen la siguiente forma. Muchos de los espacios nacen a consideración de
algunos cálculo que se realizar en la tabla usando la capacidades de ~org~ para
su manipulación.

|   | Cartera | Producto | Serie   | Fecha    | Status    | Cantidad | Valor unitario | Costo agregado | Comisión | IVA | Costo total | Anotaciones |
|   |         |          |         |          |           |          |                |                |          |     |             |             |
|---+---------+----------+---------+----------+-----------+----------+----------------+----------------+----------+-----+-------------+-------------|
|   | STR     | STR      | STR/NUM | %Y-%m-%d | DONE/TODO | NUM      | NUM            | NUM            | NUM      | NUM | NUM         | TEXT        |

Hay que tener en cuenta que esas tablas tienen una finalidad de ayuda visual y
contienen información que puede ser reconstruida después o es innecesaria por lo
que decide no guardarse. Además de esos valores descartados, debe asegurarse que
los valores tengan la estructura correcta y en particular, deben distinguirse
las tablas que registran las compras (valor positivo) de las ventas (valor
negativo). Durante el registro de las tablas, no se hace explícito ese signo lo
que hace imperativo que se registre esto durante el procesamiento en la
siguiente función.
#+name: bulk:_op_processing
#+begin_src python :tangle no
@staticmethod
def _bulk_op_processing(data_table, start_row=2, sign=1):
     """Al recibir la tabla, debe definirse si el valor de la transacción es
     positivo o negativo y si admitir sólo operaciones completadas. También se
     hacen ajustes menores a los tipos de datos para garantizar que sean los
     mismos que se tienen en la base de datos. La función se aisla porque el
     proceso se realiza sobre al menos dos tablas de la misma forma antes de
     continuar"""

     # Regenera las filas de tabla, transformando la información que se ingresa
     return [(str(symbol), str(serie), int(datetime.strptime(date, "%Y-%m-%d").timestamp()), sign*qty, sign*price)
             for _, _, symbol, serie, date, status, qty, _, _, _, _, price,_ in data_table[start_row:]
             if status == 'DONE']
#+end_src

Una vez procesada la información de la tabla, tenemos una colección de todos los
tickets emitidos en una sola lista. La tabla de compras busca registrar las
operaciones en un día, y aunque la tabla registre varias ventas o compras en un
día, deben consolidarse acumulándose en una sola y esto es lo que se guarda en
la tabla. Tiene un efecto indeseable que combinaría compras y ventas de un
producto en un sólo día pero eso se considera irrelevante al no ser una práctica
deseable. Una vez acumuladas, se generan las filas que van a almacenarse y se
guardan en la tabla correspondiente.
#+name: bulk:insert_buys
#+begin_src python :tangle no
def bulk_insert_buys(self, buys_table, sells_table, start_row=2):
    """Para una tabla con la información relevante para una compra (si sign=1) o
    una venta (si sign=-1), inserta esa información dentro de la base de datos
    con una potencial modificación: Para insertar una fila con un elemento único
    se requiere símbolo y fecha de compra/venta. Esto quiere decir las filas
    deben acumularse antes de insertarse."""

    # Define el query requerida para la operación
    SQL_INSERT = "INSERT OR IGNORE INTO buys(symbol,qty,price,date) VALUES (?,?,?,?)"

    # Extrae los IDs de la base de datos
    ids_dictionary = self._symbols_ids()

    # Une los tickets de compra y venta en una lista
    tickets = self._bulk_op_processing(buys_table, start_row=start_row, sign=1) + self._bulk_op_processing(sells_table, start_row=start_row, sign=-1)

    # Acumula los valores de compra y venta diarios por symbol+serie+date usando
    # el ID de symbol+serie en la base de datos
    day_tickets = {}
    for symbol, serie, utc_timestamp, qty, price in tickets:
        ticket_key = (ids_dictionary[(symbol,serie)], utc_timestamp)
        ticket_qty_price = day_tickets.get(ticket_key, (0.0, 0.0))
        day_tickets[ticket_key] = tuple(a + b for a, b in zip(ticket_qty_price, (qty,price)))

    # Organiza la información acumulada para insertar la información
    data = [ (symbol_id, qty, price, utc_timestamp) for (symbol_id, utc_timestamp), (qty, price) in day_tickets.items() ]

    # Devuelve el resultado de ejecutar la query
    return self._execute_many(SQL_INSERT, data)
#+end_src

Finalmente, el objetivo principal de la base de datos es guardar los precios que
se han descargado para no tener que consultarlos de vuelta. Para eso, se atrae
el diccionario con el que se interactúa en los ~scrappers~ y convierte éste en
las filas que deben insertarse en la tabla de precios.
#+name: bulk:insert_prices
#+begin_src python :tangle no
def bulk_insert_prices(self, scraps_dictionary):
    # Define el query requerida para la operación
    SQL_INSERT = "INSERT OR IGNORE INTO prices(symbol,date,price) VALUES (?,?,?)"

    # Extrae los IDs de la base de datos
    ids_dictionary = self._symbols_ids()

    # Organiza las inserciones que debe realizarse como tuplas
    data = [ (ids_dictionary[symbol_key], self._date2utc(date) , price)
             for symbol_key, prices_dictionary in scraps_dictionary.items()
             for date, price in prices_dictionary.items()]

    return self._execute_many(SQL_INSERT, data)
#+end_src

* Base de datos
La estructura de la base de datos es sencilla y la podemos describir con un
comando de ~SQL~. Ésta contiene tres tablas para almacenar los productos
financieros que se utilizan, los precios de los productos que se usan, y las
compras/ventas de cada uno. Con todo esto, se pretende dar un seguimiento del
portafolio. En el caso de un producto, se usa su símbolo y serie para que este
sea único junto con el identificador como clave primaria. En el caso de los
precios, el rol de la unicidad lo juega el identificador del símbolo (como clave
externa) y la fecha, sólo se quiere un precio por día. Finalmente, la unicidad
en una compra se consigue con el símbolo (de nuevo como clave externa), junto al
precio y la fecha. Esto último es un poco forzado y de momento funciona pero
como las fechas se guardan como un entero representando la una hora estándar del
día en UTC, se podría cambiar para que fuera única en el sentido de la hora con
segundos incluidos si fuera necesario.
#+name: db-structure
#+begin_src sqlite :results silent
CREATE TABLE IF NOT EXISTS products (
       id INTEGER UNIQUE PRIMARY KEY,
       symbol TEXT NOT NULL,
       serie TEXT,
       src TEXT,
       secc TEXT,
       UNIQUE(symbol, serie));
CREATE TABLE IF NOT EXISTS prices (
       id INTEGER UNIQUE PRIMARY KEY,
       symbol INTEGER NOT NULL,
       date INTEGER NOT NULL,
       price REAL NOT NULL,
       UNIQUE(symbol, date),
       FOREIGN KEY(symbol) REFERENCES products(id));
CREATE TABLE IF NOT EXISTS buys (
       id INTEGER UNIQUE PRIMARY KEY,
       symbol INTEGER NOT NULL,
       qty REAL NOT NULL,
       price REAL NOT NULL,
       date INTEGER NOT NULL,
       UNIQUE(symbol, price, date),
       FOREIGN KEY(symbol) REFERENCES products(id));
#+end_src
